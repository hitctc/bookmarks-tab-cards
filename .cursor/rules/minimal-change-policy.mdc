---
alwaysApply: true
---

# Minimal Change Policy（最小改动策略）

## 目的

在保证功能正确的前提下，把改动范围压到最小，降低回归风险，提升可审阅性与可回滚性。

## 必须

- **只改与目标直接相关的代码**：任何“顺手优化/顺手清理”都要先说明必要性。
- **优先局部修补**：能在函数内部解决，就不要跨文件改；能加小函数，就不要重构大结构。
- **保持外部行为稳定**：尽量不改公共接口、函数签名、事件名、协议字段名、返回结构。
- **保持风格稳定**：不要做全文件格式化、不要无意义调整缩进/换行/排序。
- **必要时先问再改**：上下文不足、协议不确定、边界不明确时先提问。

## 禁止

- **重写整文件/整模块**（除非用户明确要求）。
- **无关重排**：重排 import、统一命名、目录搬家、批量替换、批量改格式。
- **引入新依赖**（库/框架/工具）或改变构建流程，除非先征得同意。
- **扩大改动面**：为了“更优雅”改动无关逻辑、顺手改其它功能点。
- **做假设当事实**：没有看到代码/数据/日志，就不要编造“现状如此”。

## 允许扩大改动的条件（满足其一）

扩大改动前必须先说明：原因、影响范围、回滚方式。

- 现有结构导致 bug/安全问题，局部补丁不可控或不可维护。
- 同一段逻辑重复出现 ≥ 3 次，且抽取后能明显降低后续维护成本。
- 新增逻辑无法在现有结构里安全落地（会引入更多分支/拷贝/副作用）。

## 输出要求（给 AI）

默认按以下顺序输出：

1. **变更目标**：一句话说明你要达到的结果。
2. **风险点**：列出可能引发回归的点（越具体越好）。
3. **改动点清单**：按文件/函数列出“会动哪里、为什么动”。
4. **最小改动方案**：说明为什么这是最小改动。
5. **代码改动**：优先给 diff 或局部片段，避免整文件重贴。
6. **验证方式**：给可执行的验证步骤（命令/操作路径/关键观察点）。
7. **回滚建议**：如果改坏了怎么快速撤回。

## 自检清单（改完再看一遍）

- 是否只改了与目标相关的文件与函数？
- 是否引入了无关格式化/命名调整/目录结构变化？
- 是否保持了公共接口与行为一致（除非需求要求变更）？
- 是否写清楚了验证步骤与回滚方式？


